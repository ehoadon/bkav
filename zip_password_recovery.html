<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZIP Password Recovery Tool</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.2em;
        }
        
        .upload-area {
            border: 3px dashed #cbd5e0;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #667eea;
            background: #f7fafc;
        }
        
        .upload-area.dragover {
            border-color: #667eea;
            background: #ebf8ff;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 10px 5px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .progress-container {
            background: #f7fafc;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }
        
        .progress-bar {
            background: #e2e8f0;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #48bb78, #38a169);
            height: 100%;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }
        
        .status.success {
            background: #f0fff4;
            border: 1px solid #9ae6b4;
            color: #276749;
        }
        
        .status.error {
            background: #fed7d7;
            border: 1px solid #feb2b2;
            color: #c53030;
        }
        
        .status.info {
            background: #ebf8ff;
            border: 1px solid #90cdf4;
            color: #2c5282;
        }
        
        .password-input {
            margin: 20px 0;
        }
        
        .password-input input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            margin-top: 10px;
        }
        
        .password-input input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .options {
            background: #f7fafc;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .checkbox-group {
            margin: 15px 0;
        }
        
        .checkbox-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-weight: 500;
        }
        
        .checkbox-group input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        
        .custom-passwords {
            margin-top: 15px;
        }
        
        .custom-passwords textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-family: monospace;
            resize: vertical;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-item {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #4a5568;
        }
        
        .stat-label {
            font-size: 12px;
            color: #718096;
            text-transform: uppercase;
            margin-top: 5px;
        }
        
        .log {
            background: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin-top: 20px;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .log-try {
            color: #90cdf4;
        }
        
        .log-success {
            color: #68d391;
            font-weight: bold;
        }
        
        .log-error {
            color: #feb2b2;
        }
        
        .hex-viewer {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 15px 0;
            height: 150px;
            overflow-y: auto;
        }
        
        .warning {
            background: #fffbeb;
            border: 1px solid #f6e05e;
            color: #744210;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîì ZIP Password Recovery Tool (Advanced)</h1>
        
        <div class="warning">
            ‚ö†Ô∏è <strong>L∆∞u √Ω:</strong> Tool n√†y s·ª≠ d·ª•ng ph∆∞∆°ng ph√°p brute force ƒë·ªÉ th·ª≠ t·ª´ng m·∫≠t kh·∫©u. 
            Ch·ªâ ho·∫°t ƒë·ªông v·ªõi ZIP encryption c≈© (ZipCrypto), kh√¥ng h·ªó tr·ª£ AES encryption.
        </div>
        
        <div class="upload-area" id="uploadArea">
            <div style="font-size: 48px; margin-bottom: 15px;">üìÅ</div>
            <div style="font-size: 18px; margin-bottom: 10px;">K√©o th·∫£ file ZIP v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn</div>
            <div style="color: #718096;">H·ªó tr·ª£ file ZIP ƒë∆∞·ª£c m√£ h√≥a b·∫±ng ph∆∞∆°ng ph√°p c≈© (ZipCrypto)</div>
            <input type="file" id="zipFile" accept=".zip" />
        </div>
        
        <div id="fileInfo" style="display: none;">
            <h3>üìã Th√¥ng tin file:</h3>
            <div id="fileDetails"></div>
            <div class="hex-viewer" id="hexViewer"></div>
        </div>
        
        <div class="password-input">
            <label for="manualPassword"><strong>Th·ª≠ m·∫≠t kh·∫©u th·ªß c√¥ng:</strong></label>
            <input type="password" id="manualPassword" placeholder="Nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ th·ª≠..." />
            <button class="btn" onclick="tryManualPassword()">Th·ª≠ m·∫≠t kh·∫©u</button>
        </div>
        
        <div class="options">
            <h3>‚öôÔ∏è T√πy ch·ªçn t√¨m ki·∫øm t·ª± ƒë·ªông</h3>
            
            <div class="checkbox-group">
                <label>
                    <input type="checkbox" id="useCommon" checked />
                    Th·ª≠ m·∫≠t kh·∫©u ph·ªï bi·∫øn (123456, password, admin, ...)
                </label>
            </div>
            
            <div class="checkbox-group">
                <label>
                    <input type="checkbox" id="useNumbers" />
                    Th·ª≠ s·ªë t·ª´ 0000-9999
                </label>
            </div>
            
            <div class="checkbox-group">
                <label>
                    <input type="checkbox" id="useDates" />
                    Th·ª≠ ng√†y th√°ng (1990-2024)
                </label>
            </div>
            
            <div class="checkbox-group">
                <label>
                    <input type="checkbox" id="useCustom" />
                    S·ª≠ d·ª•ng danh s√°ch m·∫≠t kh·∫©u t√πy ch·ªânh
                </label>
            </div>
            
            <div class="custom-passwords" id="customPasswords" style="display: none;">
                <textarea id="customPasswordList" placeholder="Nh·∫≠p m·ªói m·∫≠t kh·∫©u tr√™n m·ªôt d√≤ng..."></textarea>
            </div>
        </div>
        
        <div style="text-align: center;">
            <button class="btn" id="startBtn" onclick="startCracking()" disabled>üöÄ B·∫Øt ƒë·∫ßu t√¨m m·∫≠t kh·∫©u</button>
            <button class="btn" id="stopBtn" onclick="stopCracking()" disabled style="background: #e53e3e;">‚èπÔ∏è D·ª´ng l·∫°i</button>
        </div>
        
        <div class="progress-container" id="progressContainer">
            <h4>üîç ƒêang t√¨m m·∫≠t kh·∫©u...</h4>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="progressText">0%</div>
            
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-number" id="triedCount">0</div>
                    <div class="stat-label">ƒê√£ th·ª≠</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="totalCount">0</div>
                    <div class="stat-label">T·ªïng s·ªë</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="speedCount">0</div>
                    <div class="stat-label">M·∫≠t kh·∫©u/gi√¢y</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="etaCount">--</div>
                    <div class="stat-label">Th·ªùi gian ∆∞·ªõc t√≠nh</div>
                </div>
            </div>
        </div>
        
        <div class="status" id="statusDiv"></div>
        
        <div class="log" id="logDiv"></div>
    </div>

    <script>
        let zipData = null;
        let isRunning = false;
        let shouldStop = false;
        let startTime = 0;
        let triedPasswords = 0;
        
        // Common passwords list
        const commonPasswords = [
            '123456', 'password', '123456789', '12345678', '12345', '1234567',
            '1234567890', 'qwerty', 'abc123', '111111', '123123', 'admin',
            '000000', '1234', 'iloveyou', '1q2w3e4r', '123321', 'dragon',
            'master', 'monkey', 'letmein', 'login', 'princess', 'qwerty123',
            'solo', 'passw0rd', 'starwars', '1234567891', 'password1',
            '1qaz2wsx', '123456a', '123123123', 'password123', '1111111',
            'welcome', '1q2w3e', 'superman', 'michael', 'football',
            'jesus', 'freedom', '123654', 'hunter', 'shadow', 'fuckyou',
            'whatever', '12345678910', '123abc', 'password!', '123456789a',
            'baseball', 'hello', 'charlie', 'orange', 'biteme',
            '', ' ', 'test', 'demo', 'sample', 'example', 'backup'
        ];

        // Setup event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('zipFile');
            const useCustomCheckbox = document.getElementById('useCustom');
            const customPasswordsDiv = document.getElementById('customPasswords');

            uploadArea.addEventListener('click', () => fileInput.click());
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('drop', handleDrop);
            fileInput.addEventListener('change', handleFileSelect);
            
            useCustomCheckbox.addEventListener('change', function() {
                customPasswordsDiv.style.display = this.checked ? 'block' : 'none';
            });
        });

        function handleDragOver(e) {
            e.preventDefault();
            document.getElementById('uploadArea').classList.add('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            document.getElementById('uploadArea').classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                loadZipFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                loadZipFile(files[0]);
            }
        }

        function loadZipFile(file) {
            if (!file.name.toLowerCase().endsWith('.zip')) {
                showStatus('error', '‚ùå Vui l√≤ng ch·ªçn file ZIP h·ª£p l·ªá!');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                zipData = new Uint8Array(e.target.result);
                analyzeZipFile(zipData, file);
            };
            reader.readAsArrayBuffer(file);
        }

        function analyzeZipFile(data, file) {
            try {
                // Check ZIP signature
                if (data[0] !== 0x50 || data[1] !== 0x4B) {
                    showStatus('error', '‚ùå File kh√¥ng ph·∫£i ƒë·ªãnh d·∫°ng ZIP!');
                    return;
                }

                // Analyze ZIP structure
                let isEncrypted = false;
                let fileCount = 0;
                let encryptionDetails = [];
                
                // Look for local file headers
                for (let i = 0; i < data.length - 30; i++) {
                    if (data[i] === 0x50 && data[i+1] === 0x4B && data[i+2] === 0x03 && data[i+3] === 0x04) {
                        fileCount++;
                        const flags = data[i + 6] | (data[i + 7] << 8);
                        const compressionMethod = data[i + 8] | (data[i + 9] << 8);
                        const nameLen = data[i + 26] | (data[i + 27] << 8);
                        
                        // Get filename
                        let filename = '';
                        for (let j = 0; j < nameLen; j++) {
                            filename += String.fromCharCode(data[i + 30 + j]);
                        }
                        
                        if (flags & 0x01) { // Check if encrypted bit is set
                            isEncrypted = true;
                            encryptionDetails.push({
                                filename: filename,
                                compressionMethod: compressionMethod,
                                flags: flags,
                                offset: i
                            });
                        }
                    }
                }

                const fileInfo = document.getElementById('fileInfo');
                const fileDetails = document.getElementById('fileDetails');
                
                let encryptionInfo = '';
                if (isEncrypted) {
                    encryptionInfo = '<br><strong>Chi ti·∫øt m√£ h√≥a:</strong><ul>';
                    encryptionDetails.forEach(detail => {
                        const encType = detail.compressionMethod === 99 ? 'AES' : 'ZipCrypto';
                        encryptionInfo += `<li>${detail.filename} - ${encType} (Method: ${detail.compressionMethod})</li>`;
                    });
                    encryptionInfo += '</ul>';
                    
                    // Check if any file uses AES
                    const hasAES = encryptionDetails.some(d => d.compressionMethod === 99);
                    if (hasAES) {
                        encryptionInfo += '<div style="color: red; font-weight: bold;">‚ö†Ô∏è Ph√°t hi·ªán m√£ h√≥a AES - Tool n√†y ch·ªâ h·ªó tr·ª£ ZipCrypto!</div>';
                    }
                }
                
                fileDetails.innerHTML = `
                    <p><strong>T√™n file:</strong> ${file.name}</p>
                    <p><strong>K√≠ch th∆∞·ªõc:</strong> ${formatFileSize(file.size)}</p>
                    <p><strong>S·ªë file b√™n trong:</strong> ${fileCount}</p>
                    <p><strong>Tr·∫°ng th√°i m√£ h√≥a:</strong> ${isEncrypted ? 'üîí C√≥ m√£ h√≥a' : 'üîì Kh√¥ng m√£ h√≥a'}</p>
                    ${encryptionInfo}
                `;
                
                // Show hex dump of first 400 bytes for better analysis
                const hexViewer = document.getElementById('hexViewer');
                let hexDump = 'Hex dump (400 bytes ƒë·∫ßu - ph√¢n t√≠ch structure):\n';
                for (let i = 0; i < Math.min(400, data.length); i += 16) {
                    let line = i.toString(16).padStart(8, '0') + ': ';
                    let ascii = '';
                    for (let j = 0; j < 16 && i + j < data.length && i + j < 400; j++) {
                        const byte = data[i + j];
                        line += byte.toString(16).padStart(2, '0') + ' ';
                        ascii += (byte >= 32 && byte < 127) ? String.fromCharCode(byte) : '.';
                    }
                    line = line.padEnd(57, ' ') + ascii;
                    hexDump += line + '\n';
                }
                hexViewer.textContent = hexDump;
                
                fileInfo.style.display = 'block';
                
                if (isEncrypted) {
                    const hasOnlyZipCrypto = !encryptionDetails.some(d => d.compressionMethod === 99);
                    if (hasOnlyZipCrypto) {
                        showStatus('success', `‚úÖ ƒê√£ t·∫£i file ZIP v·ªõi ZipCrypto (${encryptionDetails.length} file m√£ h√≥a)`);
                        document.getElementById('startBtn').disabled = false;
                        addLog(`üìÅ File ZipCrypto ph√°t hi·ªán: ${encryptionDetails.length} file`, 'log-success');
                    } else {
                        showStatus('error', '‚ùå File ch·ª©a m√£ h√≥a AES - kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£!');
                        addLog(`üìÅ File c√≥ AES encryption - kh√¥ng th·ªÉ crack`, 'log-error');
                    }
                } else {
                    showStatus('error', '‚ùå File ZIP n√†y kh√¥ng ƒë∆∞·ª£c m√£ h√≥a b·∫±ng m·∫≠t kh·∫©u!');
                    addLog(`üìÅ File kh√¥ng ƒë∆∞·ª£c m√£ h√≥a`, 'log-error');
                }

            } catch (error) {
                showStatus('error', `‚ùå L·ªói ph√¢n t√≠ch file: ${error.message}`);
                addLog(`‚ùå L·ªói: ${error.message}`, 'log-error');
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Corrected ZipCrypto implementation
        function initKeys(password) {
            const keys = [0x12345678, 0x23456789, 0x34567890];
            
            for (let i = 0; i < password.length; i++) {
                updateKeys(keys, password.charCodeAt(i));
            }
            
            return keys;
        }

        function updateKeys(keys, byte) {
            keys[0] = crc32(keys[0], byte);
            keys[1] = (keys[1] + (keys[0] & 0xff)) & 0xffffffff;
            keys[1] = (keys[1] * 134775813 + 1) & 0xffffffff;
            keys[2] = crc32(keys[2], (keys[1] >> 24) & 0xff);
        }

        function crc32(crc, byte) {
            return ((crc ^ byte) & 0xff) ^ ((crc >> 8) & 0xffffff);
        }

        function decryptByte(keys) {
            const temp = (keys[2] | 2) & 0xffffffff;
            return ((temp * (temp ^ 1)) >> 8) & 0xff;
        }

        async function testPassword(password) {
            try {
                const data = zipData;
                
                // Find encrypted files
                for (let i = 0; i < data.length - 30; i++) {
                    if (data[i] === 0x50 && data[i+1] === 0x4B && data[i+2] === 0x03 && data[i+3] === 0x04) {
                        const flags = data[i + 6] | (data[i + 7] << 8);
                        if (!(flags & 0x01)) continue; // Skip unencrypted files
                        
                        const compressionMethod = data[i + 8] | (data[i + 9] << 8);
                        if (compressionMethod === 99) continue; // Skip AES
                        
                        const nameLen = data[i + 26] | (data[i + 27] << 8);
                        const extraLen = data[i + 28] | (data[i + 29] << 8);
                        const dataStart = i + 30 + nameLen + extraLen;
                        
                        if (dataStart + 12 >= data.length) continue;
                        
                        // Get CRC32 and modification time
                        const crc32 = (data[i + 14] | (data[i + 15] << 8) | (data[i + 16] << 16) | (data[i + 17] << 24)) >>> 0;
                        const modTime = data[i + 10] | (data[i + 11] << 8);
                        
                        // Initialize keys with password
                        const keys = initKeys(password);
                        
                        // Decrypt the 12-byte header
                        const decryptedHeader = new Array(12);
                        const tempKeys = [...keys];
                        
                        for (let h = 0; h < 12; h++) {
                            const encryptedByte = data[dataStart + h];
                            const decryptedByte = encryptedByte ^ decryptByte(tempKeys);
                            updateKeys(tempKeys, decryptedByte);
                            decryptedHeader[h] = decryptedByte;
                        }
                        
                        // Validate password using multiple methods
                        const crcHighByte = (crc32 >>> 24) & 0xff;
                        const timeHighByte = (modTime >>> 8) & 0xff;
                        
                        // Method 1: Check CRC high byte
                        if (decryptedHeader[11] === crcHighByte) {
                            addLog(`‚úÖ Password "${password}" works! CRC match: 0x${crcHighByte.toString(16)}`, 'log-success');
                            return true;
                        }
                        
                        // Method 2: Check modification time high byte
                        if (decryptedHeader[11] === timeHighByte) {
                            addLog(`‚úÖ Password "${password}" works! Time match: 0x${timeHighByte.toString(16)}`, 'log-success');
                            return true;
                        }
                        
                        // Method 3: Additional validation - check if decrypted content looks reasonable
                        if (decryptedHeader[11] === crcHighByte || decryptedHeader[11] === timeHighByte) {
                            // Try to decrypt more data to verify
                            const validationKeys = [...keys];
                            
                            // Reset keys and decrypt header again
                            for (let h = 0; h < 12; h++) {
                                const encryptedByte = data[dataStart + h];
                                const decryptedByte = encryptedByte ^ decryptByte(validationKeys);
                                updateKeys(validationKeys, decryptedByte);
                            }
                            
                            // Decrypt next 50 bytes and check for reasonable content
                            let validBytes = 0;
                            for (let k = 0; k < Math.min(50, data.length - dataStart - 12); k++) {
                                const encryptedByte = data[dataStart + 12 + k];
                                const decryptedByte = encryptedByte ^ decryptByte(validationKeys);
                                updateKeys(validationKeys, decryptedByte);
                                
                                // Count printable ASCII bytes
                                if (decryptedByte >= 32 && decryptedByte <= 126) {
                                    validBytes++;
                                }
                            }
                            
                            // If more than 60% are printable ASCII, consider it valid
                            if (validBytes >= 25) {
                                addLog(`‚úÖ Password "${password}" works! Content validation passed`, 'log-success');
                                return true;
                            }
                        }
                    }
                }
                
                return false;
                
            } catch (error) {
                addLog(`üí• L·ªói test password: ${error.message}`, 'log-error');
                return false;
            }
        }

        async function tryManualPassword() {
            const password = document.getElementById('manualPassword').value;
            if (!password) {
                showStatus('error', '‚ùå Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u!');
                return;
            }

            if (!zipData) {
                showStatus('error', '‚ùå Vui l√≤ng ch·ªçn file ZIP tr∆∞·ªõc!');
                return;
            }

            addLog(`üîë ƒêang th·ª≠ m·∫≠t kh·∫©u: "${password}"`, 'log-try');
            
            const testBtn = event.target;
            testBtn.disabled = true;
            testBtn.textContent = '‚è≥ ƒêang th·ª≠...';
            
            try {
                const success = await testPassword(password);
                if (success) {
                    showStatus('success', `üéâ T√¨m th·∫•y m·∫≠t kh·∫©u: "${password}"`);
                    addLog(`‚úÖ M·∫¨T KH·∫®U ƒê√öNG: "${password}"`, 'log-success');
                } else {
                    showStatus('error', '‚ùå M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng!');
                    addLog(`‚ùå M·∫≠t kh·∫©u sai: "${password}"`, 'log-error');
                }
            } catch (error) {
                showStatus('error', `‚ùå L·ªói khi th·ª≠ m·∫≠t kh·∫©u: ${error.message}`);
                addLog(`üí• L·ªói: ${error.message}`, 'log-error');
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = 'Th·ª≠ m·∫≠t kh·∫©u';
            }
        }

        function generatePasswordList() {
            let passwords = [];
            
            if (document.getElementById('useCommon').checked) {
                passwords = passwords.concat(commonPasswords);
            }
            
            if (document.getElementById('useNumbers').checked) {
                for (let i = 0; i <= 9999; i++) {
                    passwords.push(i.toString().padStart(4, '0'));
                }
            }
            
            if (document.getElementById('useDates').checked) {
                for (let year = 1990; year <= 2024; year++) {
                    passwords.push(year.toString());
                    for (let month = 1; month <= 12; month++) {
                        for (let day = 1; day <= 31; day++) {
                            const dateStr1 = `${day.toString().padStart(2, '0')}${month.toString().padStart(2, '0')}${year}`;
                            const dateStr2 = `${year}${month.toString().padStart(2, '0')}${day.toString().padStart(2, '0')}`;
                            passwords.push(dateStr1, dateStr2);
                        }
                    }
                }
            }
            
            if (document.getElementById('useCustom').checked) {
                const customText = document.getElementById('customPasswordList').value;
                const customPasswords = customText.split('\n')
                    .map(p => p.trim())
                    .filter(p => p.length > 0);
                passwords = passwords.concat(customPasswords);
            }
            
            return [...new Set(passwords)];
        }

        async function startCracking() {
            if (!zipData) {
                showStatus('error', '‚ùå Vui l√≤ng ch·ªçn file ZIP tr∆∞·ªõc!');
                return;
            }

            const passwords = generatePasswordList();
            if (passwords.length === 0) {
                showStatus('error', '‚ùå Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt t√πy ch·ªçn t√¨m ki·∫øm!');
                return;
            }

            isRunning = true;
            shouldStop = false;
            triedPasswords = 0;
            startTime = Date.now();
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('totalCount').textContent = passwords.length;
            
            showStatus('info', 'üîç ƒêang b·∫Øt ƒë·∫ßu t√¨m m·∫≠t kh·∫©u...');
            addLog(`üöÄ B·∫Øt ƒë·∫ßu v·ªõi ${passwords.length} m·∫≠t kh·∫©u`, 'log-try');
            
            for (let i = 0; i < passwords.length && !shouldStop; i++) {
                const password = passwords[i];
                triedPasswords++;
                
                const progress = (i / passwords.length) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressText').textContent = Math.round(progress) + '%';
                document.getElementById('triedCount').textContent = triedPasswords;
                
                const elapsed = (Date.now() - startTime) / 1000;
                const speed = Math.round(triedPasswords / elapsed);
                const remaining = passwords.length - triedPasswords;
                const eta = speed > 0 ? Math.round(remaining / speed) : 0;
                
                document.getElementById('speedCount').textContent = speed;
                document.getElementById('etaCount').textContent = eta > 0 ? eta + 's' : '--';
                
                if (i % 100 === 0) {
                    addLog(`üîë Th·ª≠: ${password}`, 'log-try');
                }
                
                const success = await testPassword(password);
                if (success) {
                    showStatus('success', `üéâ TH√ÄNH C√îNG! M·∫≠t kh·∫©u l√†: "${password}"`);
                    addLog(`üèÜ T√åM TH·∫§Y M·∫¨T KH·∫®U: ${password}`, 'log-success');
                    stopCracking();
                    return;
                }
                
                if (i % 100 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
            
            if (!shouldStop) {
                showStatus('error', '‚ùå Kh√¥ng t√¨m th·∫•y m·∫≠t kh·∫©u trong danh s√°ch ƒë√£ th·ª≠!');
                addLog('‚ùå T√¨m ki·∫øm ho√†n th√†nh - Kh√¥ng t√¨m th·∫•y m·∫≠t kh·∫©u', 'log-error');
            }
            
            stopCracking();
        }

        function stopCracking() {
            isRunning = false;
            shouldStop = true;
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            if (shouldStop && triedPasswords > 0) {
                addLog('‚èπÔ∏è ƒê√£ d·ª´ng t√¨m ki·∫øm', 'log-error');
            }
        }

        function showStatus(type, message) {
            const statusDiv = document.getElementById('statusDiv');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }

        function addLog(message, className = '') {
            const logDiv = document.getElementById('logDiv');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${className}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            
            // Keep only last 100 log entries
            while (logDiv.children.length > 100) {
                logDiv.removeChild(logDiv.firstChild);
            }
        }
    </script>
</body>
</html>